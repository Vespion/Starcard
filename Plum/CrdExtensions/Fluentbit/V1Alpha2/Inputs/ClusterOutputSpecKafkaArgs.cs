// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Types.Inputs.Fluentbit.V1Alpha2
{

    /// <summary>
    /// Kafka defines Kafka Output configuration.
    /// </summary>
    public class ClusterOutputSpecKafkaArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Single of multiple list of Kafka Brokers, e.g: 192.168.1.3:9092, 192.168.1.4:9092.
        /// </summary>
        [Input("brokers")]
        public Input<string>? Brokers { get; set; }

        /// <summary>
        /// adds unknown topics (found in Topic_Key) to Topics. So in Topics only a default topic needs to be configured
        /// </summary>
        [Input("dynamicTopic")]
        public Input<bool>? DynamicTopic { get; set; }

        /// <summary>
        /// Specify data format, options available: json, msgpack.
        /// </summary>
        [Input("format")]
        public Input<string>? Format { get; set; }

        /// <summary>
        /// Optional key to store the message
        /// </summary>
        [Input("messageKey")]
        public Input<string>? MessageKey { get; set; }

        /// <summary>
        /// If set, the value of Message_Key_Field in the record will indicate the message key. If not set nor found in the record, Message_Key will be used (if set).
        /// </summary>
        [Input("messageKeyField")]
        public Input<string>? MessageKeyField { get; set; }

        /// <summary>
        /// Fluent Bit queues data into rdkafka library, if for some reason the underlying library cannot flush the records the queue might fills up blocking new addition of records. The queue_full_retries option set the number of local retries to enqueue the data. The default value is 10 times, the interval between each retry is 1 second. Setting the queue_full_retries value to 0 set's an unlimited number of retries.
        /// </summary>
        [Input("queueFullRetries")]
        public Input<int>? QueueFullRetries { get; set; }

        [Input("rdkafka")]
        private InputMap<string>? _rdkafka;

        /// <summary>
        /// {property} can be any librdkafka properties
        /// </summary>
        public InputMap<string> Rdkafka
        {
            get => _rdkafka ?? (_rdkafka = new InputMap<string>());
            set => _rdkafka = value;
        }

        /// <summary>
        /// iso8601 or double
        /// </summary>
        [Input("timestampFormat")]
        public Input<string>? TimestampFormat { get; set; }

        /// <summary>
        /// Set the key to store the record timestamp
        /// </summary>
        [Input("timestampKey")]
        public Input<string>? TimestampKey { get; set; }

        /// <summary>
        /// If multiple Topics exists, the value of Topic_Key in the record will indicate the topic to use. E.g: if Topic_Key is router and the record is {"key1": 123, "router": "route_2"}, Fluent Bit will use topic route_2. Note that if the value of Topic_Key is not present in Topics, then by default the first topic in the Topics list will indicate the topic to be used.
        /// </summary>
        [Input("topicKey")]
        public Input<string>? TopicKey { get; set; }

        /// <summary>
        /// Single entry or list of topics separated by comma (,) that Fluent Bit will use to send messages to Kafka. If only one topic is set, that one will be used for all records. Instead if multiple topics exists, the one set in the record by Topic_Key will be used.
        /// </summary>
        [Input("topics")]
        public Input<string>? Topics { get; set; }

        public ClusterOutputSpecKafkaArgs()
        {
        }
        public static new ClusterOutputSpecKafkaArgs Empty => new ClusterOutputSpecKafkaArgs();
    }
}
