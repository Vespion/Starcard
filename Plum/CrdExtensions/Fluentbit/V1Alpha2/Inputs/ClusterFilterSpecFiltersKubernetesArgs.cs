// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Kubernetes.Types.Inputs.Fluentbit.V1Alpha2
{

    /// <summary>
    /// Kubernetes defines Kubernetes Filter configuration.
    /// </summary>
    public class ClusterFilterSpecFiltersKubernetesArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Alias for the plugin
        /// </summary>
        [Input("alias")]
        public Input<string>? Alias { get; set; }

        /// <summary>
        /// Include Kubernetes resource annotations in the extra metadata.
        /// </summary>
        [Input("annotations")]
        public Input<bool>? Annotations { get; set; }

        /// <summary>
        /// Set the buffer size for HTTP client when reading responses from Kubernetes API server.
        /// </summary>
        [Input("bufferSize")]
        public Input<string>? BufferSize { get; set; }

        /// <summary>
        /// When enabled, metadata will be fetched from K8s when docker_id is changed.
        /// </summary>
        [Input("cacheUseDockerId")]
        public Input<bool>? CacheUseDockerId { get; set; }

        /// <summary>
        /// DNS lookup retries N times until the network start working
        /// </summary>
        [Input("dnsRetries")]
        public Input<int>? DnsRetries { get; set; }

        /// <summary>
        /// DNS lookup interval between network status checks
        /// </summary>
        [Input("dnsWaitTime")]
        public Input<int>? DnsWaitTime { get; set; }

        /// <summary>
        /// If set, use dummy-meta data (for test/dev purposes)
        /// </summary>
        [Input("dummyMeta")]
        public Input<bool>? DummyMeta { get; set; }

        /// <summary>
        /// Allow Kubernetes Pods to exclude their logs from the log processor (read more about it in Kubernetes Annotations section).
        /// </summary>
        [Input("k8sLoggingExclude")]
        public Input<bool>? K8sLoggingExclude { get; set; }

        /// <summary>
        /// Allow Kubernetes Pods to suggest a pre-defined Parser (read more about it in Kubernetes Annotations section)
        /// </summary>
        [Input("k8sLoggingParser")]
        public Input<bool>? K8sLoggingParser { get; set; }

        /// <summary>
        /// When Keep_Log is disabled, the log field is removed from the incoming message once it has been successfully merged (Merge_Log must be enabled as well).
        /// </summary>
        [Input("keepLog")]
        public Input<bool>? KeepLog { get; set; }

        /// <summary>
        /// CA certificate file
        /// </summary>
        [Input("kubeCAFile")]
        public Input<string>? KubeCAFile { get; set; }

        /// <summary>
        /// Absolute path to scan for certificate files
        /// </summary>
        [Input("kubeCAPath")]
        public Input<string>? KubeCAPath { get; set; }

        /// <summary>
        /// configurable TTL for K8s cached metadata. By default, it is set to 0 which means TTL for cache entries is disabled and cache entries are evicted at random when capacity is reached. In order to enable this option, you should set the number to a time interval. For example, set this value to 60 or 60s and cache entries which have been created more than 60s will be evicted.
        /// </summary>
        [Input("kubeMetaCacheTTL")]
        public Input<string>? KubeMetaCacheTTL { get; set; }

        /// <summary>
        /// If set, Kubernetes meta-data can be cached/pre-loaded from files in JSON format in this directory, named as namespace-pod.meta
        /// </summary>
        [Input("kubeMetaPreloadCacheDir")]
        public Input<string>? KubeMetaPreloadCacheDir { get; set; }

        /// <summary>
        /// When the source records comes from Tail input plugin, this option allows to specify what's the prefix used in Tail configuration.
        /// </summary>
        [Input("kubeTagPrefix")]
        public Input<string>? KubeTagPrefix { get; set; }

        /// <summary>
        /// Token file
        /// </summary>
        [Input("kubeTokenFile")]
        public Input<string>? KubeTokenFile { get; set; }

        /// <summary>
        /// configurable 'time to live' for the K8s token. By default, it is set to 600 seconds. After this time, the token is reloaded from Kube_Token_File or the Kube_Token_Command.
        /// </summary>
        [Input("kubeTokenTTL")]
        public Input<string>? KubeTokenTTL { get; set; }

        /// <summary>
        /// API Server end-point
        /// </summary>
        [Input("kubeURL")]
        public Input<string>? KubeURL { get; set; }

        /// <summary>
        /// kubelet host using for HTTP request, this only works when Use_Kubelet set to On.
        /// </summary>
        [Input("kubeletHost")]
        public Input<string>? KubeletHost { get; set; }

        /// <summary>
        /// kubelet port using for HTTP request, this only works when useKubelet is set to On.
        /// </summary>
        [Input("kubeletPort")]
        public Input<int>? KubeletPort { get; set; }

        /// <summary>
        /// Include Kubernetes resource labels in the extra metadata.
        /// </summary>
        [Input("labels")]
        public Input<bool>? Labels { get; set; }

        /// <summary>
        /// When enabled, it checks if the log field content is a JSON string map, if so, it append the map fields as part of the log structure.
        /// </summary>
        [Input("mergeLog")]
        public Input<bool>? MergeLog { get; set; }

        /// <summary>
        /// When Merge_Log is enabled, the filter tries to assume the log field from the incoming message is a JSON string message and make a structured representation of it at the same level of the log field in the map. Now if Merge_Log_Key is set (a string name), all the new structured fields taken from the original log content are inserted under the new key.
        /// </summary>
        [Input("mergeLogKey")]
        public Input<string>? MergeLogKey { get; set; }

        /// <summary>
        /// When Merge_Log is enabled, trim (remove possible \n or \r) field values.
        /// </summary>
        [Input("mergeLogTrim")]
        public Input<bool>? MergeLogTrim { get; set; }

        /// <summary>
        /// Optional parser name to specify how to parse the data contained in the log key. Recommended use is for developers or testing only.
        /// </summary>
        [Input("mergeParser")]
        public Input<string>? MergeParser { get; set; }

        /// <summary>
        /// Set an alternative Parser to process record Tag and extract pod_name, namespace_name, container_name and docker_id. The parser must be registered in a parsers file (refer to parser filter-kube-test as an example).
        /// </summary>
        [Input("regexParser")]
        public Input<string>? RegexParser { get; set; }

        /// <summary>
        /// RetryLimit describes how many times fluent-bit should retry to send data to a specific output. If set to false fluent-bit will try indefinetly. If set to any integer N&gt;0 it will try at most N+1 times. Leading zeros are not allowed (values such as 007, 0150, 01 do not work). If this property is not defined fluent-bit will use the default value: 1.
        /// </summary>
        [Input("retryLimit")]
        public Input<string>? RetryLimit { get; set; }

        /// <summary>
        /// Debug level between 0 (nothing) and 4 (every detail).
        /// </summary>
        [Input("tlsDebug")]
        public Input<int>? TlsDebug { get; set; }

        /// <summary>
        /// When enabled, turns on certificate validation when connecting to the Kubernetes API server.
        /// </summary>
        [Input("tlsVerify")]
        public Input<bool>? TlsVerify { get; set; }

        /// <summary>
        /// When enabled, the filter reads logs coming in Journald format.
        /// </summary>
        [Input("useJournal")]
        public Input<bool>? UseJournal { get; set; }

        /// <summary>
        /// This is an optional feature flag to get metadata information from kubelet instead of calling Kube Server API to enhance the log. This could mitigate the Kube API heavy traffic issue for large cluster.
        /// </summary>
        [Input("useKubelet")]
        public Input<bool>? UseKubelet { get; set; }

        public ClusterFilterSpecFiltersKubernetesArgs()
        {
        }
        public static new ClusterFilterSpecFiltersKubernetesArgs Empty => new ClusterFilterSpecFiltersKubernetesArgs();
    }
}
